/* Copyright Ciprian Ilies */

#pragma once

#include <vector>

#include <boost/asio.hpp>
#include <boost/enable_shared_from_this.hpp>
#include <boost/bind.hpp>
#include <boost/array.hpp>
#include <boost/shared_ptr.hpp>

//using boost::asio::ip::tcp;

namespace mnet
{

class Server;

//Just so that there's some default value the server initializes to.
#define DEFAULT_PORT 9678

//This variable needs to be set in the code using this engine.
extern std::string IDENTIFICATION_MESSAGE;

class ServerClient : public boost::enable_shared_from_this<ServerClient>
{
private:
	//The data socket.
	//boost::asio::ip::tcp::socket *socket;

	ServerClient(boost::asio::io_service& io_service) : socket(io_service)
	{
	}

	void handleWrite(const boost::system::error_code& /*error*/, size_t /*bytes_transferred*/)
	{
		//std::cout << "[SERVER] handleWrite()\n";
	}

	std::string data_received = ""; //Contains the received data. Emptied every time it's read.

	void DoClose()
	{
		std::cout << "[SERVER] DoClose()\n";
		socket.close();
	}
public:
	Server *parent_server = nullptr; //The server that spawned/owns this client.

	//The socket exists as long as this is true.
	bool run = true;

	typedef boost::shared_ptr<ServerClient> pointer;

	boost::asio::ip::tcp::socket socket;

	boost::asio::io_service io_service_;

	boost::array<char, 128> m_Buffer;
	size_t m_BufLen;

	//Stops this client's update thread.
	void stop();

	//Set the socket.
	//void setSocket(boost::asio::ip::tcp::socket &the_socket);

	//Receive data, send data, etc...
	void update();

	static pointer create(boost::asio::io_service& io_service)
	{
		return pointer(new ServerClient(io_service));
	}

	boost::asio::ip::tcp::socket& getSocket()
	{
		return socket;
	}

	void start()
	{
		std::string message_ = IDENTIFICATION_MESSAGE;

		boost::asio::async_write(socket, boost::asio::buffer(message_), boost::bind(&ServerClient::handleWrite, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred));
		socket.async_receive(boost::asio::buffer(m_Buffer.data(), m_BufLen), boost::bind(&ServerClient::OnReceive, this, boost::asio::placeholders::error));
	}

	void writeMessage(std::string message)
	{
		boost::asio::async_write(socket, boost::asio::buffer(message), boost::bind(&ServerClient::handleWrite, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred));
	}

	void OnReceive(const boost::system::error_code& ErrorCode)
	{
		if (ErrorCode == 0)
		{
			if (strcmp(m_Buffer.data(), "") != 0)
			{
				//std::cout << "[SERVER] Received Data: " << m_Buffer.data() << std::endl;
			}

			socket.async_receive(boost::asio::buffer(m_Buffer, m_BufLen), boost::bind(&ServerClient::OnReceive, this, boost::asio::placeholders::error));
		}
		else
		{
			DoClose();
		}
	}

	/*
	This function does several things:
	 * Fetches the data stored in data_received
	 * Empties data_received
	*/
	std::string fetchData()
	{
		//data_received = m_Buffer;
		//std::string data(m_Buffer, m_Buffer + m_BufLen);
		//m_Buffer = "";
		//std::istream is(m_Buffer);
		//is >> data_received;
		data_received = m_Buffer.data();
		std::string temp = data_received;
		data_received = "";
		return temp;
	}

	void close();

	//TODO: Data sending ques (or whatever works best) and a method of retreiving the received data.

	//boost::asio::error::eof //To check if disconnected.
};

class Server
{
private:
	boost::asio::io_service io_service;
	boost::asio::ip::tcp::acceptor *acceptor;
	void handleAccept(ServerClient::pointer new_connection, const boost::system::error_code& error);

	//All of the currently connected clients.
	std::vector<ServerClient::pointer> clients;
public:
	//The port the server is listening on.
	int port;
	//The server will run as long as this is true.
	bool run;

	Server();
	~Server();

	//Starts the server on the port.
	//TODO: Use exception handling, not return false.
	bool start(int _port);

	//Stops the server and all of its connected clients.
	void stop();

	//Ya, it runs the server. And stuff. It is recommended to run it in its own thread.
	void update();

	//Updates all of the clients and sends pending messages. Run from the main thread.
	void updateClients();

	void startAccept();

	/*
	Removes the provided client from the clients array.
	*/
	void removeClient(ServerClient::pointer client);
};

} //namespace mnet
